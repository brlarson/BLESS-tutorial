package HeadlightSystem
public
with BLESS_Types, BLESS;

system hls --headlight system
end hls;

system implementation hls.i
subcomponents
  hl : device Headlight;
  ls : device LightSensor;
  cp  : process ControllerProcess.i;
connections
  ill : port cp.illuminate -> hl.illuminate;
  int : port ls.light_intensity -> cp.light_intensity;
end hls.i;

device Headlight
features
  illuminate : in data port BLESS_Types::Boolean
    {BLESS::Assertion => "<< HIO() >>";};  --headlight is on
end Headlight;

device LightSensor
features
  light_intensity : out data port Percent
   {BLESS::Value => "<< returns quantity p := LI >>";};  --light intensity := is not assignment 
end LightSensor;

data Percent
properties
  BLESS::Typed => "quantity p";
end Percent;

process ControllerProcess
features
  light_intensity : in data port Percent
   {BLESS::Value => "<< returns quantity p := LI >>";};  --light intensity
  illuminate : out data port BLESS_Types::Boolean
    {BLESS::Assertion => "<< HIO() >>";};  --headlight is on
end ControllerProcess;

process implementation ControllerProcess.i
subcomponents
  c : thread Controller.i;
connections
  int : port light_intensity -> c.light_intensity;
  ill : port c.illuminate -> illuminate;
end ControllerProcess.i;

thread Controller
features
  light_intensity : in data port Percent
   {BLESS::Value => "<< returns quantity p := LI >>";};  --light intensity
  illuminate : out data port BLESS_Types::Boolean
    {BLESS::Assertion => "<< HIO() >>";};  --headlight is on
properties
  Dispatch_Protocol => Timed; --
  Period => 100 ms;
end Controller;

thread implementation Controller.i
annex BLESS
{**
invariant << true >>
  
variables
  ltcl ~ time := 0.0 s  --last time confirmed light
    << GIVEN_LTCL: : ltcl = LTCL >>
     
  ltcd ~ time := 0.0 s  --last time confirmed dark
    << GIVEN_LTCD: : ltcd = LTCD >>
 
 -- we need ltcl and ltcd as these are moving points in time while 
 -- ftl and ftd are not required as headlight is off by default and LTCL = 0.0 in LTL and LTD are enough
  
  ftl ~ time := 0.0 s  --first time (continuous) light
    <<FL: : all t ~ time in ftl .. now are (LI@t > 70.0 p) >> 

  ftd ~ time := 0.0 s  --first time (continuous) dark
    <<FD: : all t ~ time in ftd .. now are LI@t < 60.0 p >>
  
states
  start : initial state
     << ltcl = 0.0 s and ltcd = 0.0 s  and ftl = 0.0 s and ftd = 0.0 s >>
  light_off : complete state  --headlight is off
  doff : state  --decide when light is off
  some_dark : complete state --dark for a while, but not long enough to turn on
    << FD() >>
  dsd : state  --decide when some dark
    << FD() >>
  light_on : complete state  --headlight is on
  don : state  --decide when on
  some_light : complete state --light for a while, but not long enough to turn off
    << FL() >>
  dsl : state  --decide when some light
    << FL() >>
  err : final state  --something went wrong (needed for Serban's theorems)
  done : final state
  
transitions
  go : start -[ ]-> light_off 
    { << ltcl = 0.0 s and ltcd = 0.0 s and GIVEN_LTCL() and GIVEN_LTCD() >>
      illuminate!(false)
    }
  
  --headlight off
  hl_off : light_off -[on dispatch]-> doff
  stay_off : doff -[light_intensity >= 60.0 p]-> light_off
  starting_dark : doff -[light_intensity < 60.0 p]-> some_dark
    { ftd := now }
  
  --dark for a while, but not long enough to turn on
  sd : some_dark -[on dispatch]-> dsd
  stay_dark : dsd -[light_intensity < 60.0 p and now-ftd < 2.0 s ]-> some_dark
  not_dark : dsd -[light_intensity >= 60.0 p ]-> light_off
  fail1 : dsd -[now-ftd > 2.0 s]-> err  --should never occur
  turn_on : dsd -[light_intensity < 60.0 p and now-ftd = 2.0 s ]-> light_on
    { 
      ltcd := now
      ; << ConfirmedDark(ltcd) and GIVEN_LTCL() and GIVEN_LTCD() >>
      illuminate!(ltcl > ltcd)
    }
  
  hl_on : light_on -[on dispatch]-> don
  stay_on : don -[light_intensity <= 70.0 p]-> light_on
  starting_light : don -[light_intensity > 70.0 p]-> some_light
    { ftl := now }

  --light for a while, but not long enough to turn off
  sl : some_light -[on dispatch]-> dsl
  stay_light : dsl -[light_intensity > 70.0 p and now-ftl < 3.0 s ]-> some_light
  not_light : dsl -[light_intensity <= 70.0 p ]-> light_on
  fail2 : dsl -[now-ftl > 3.0 s]-> err  --should never occur
  turn_off : dsl -[light_intensity > 70.0 p and now-ftl = 3.0 s ]-> light_off
    { 
      ltcl := now
      ; << ConfirmedLight(ltcl) and GIVEN_LTCL() and GIVEN_LTCD() >>
      illuminate!(ltcl > ltcd)
    }
     
**};
end Controller.i;


	
end HeadlightSystem;